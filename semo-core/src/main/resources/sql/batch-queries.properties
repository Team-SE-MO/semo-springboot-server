updateDeviceStatus=\
  UPDATE DEVICES SET STATUS = :status \
  WHERE DEVICE_ID = :deviceId
selectSessionData=\
  SELECT s.SID, "SERIAL#", s.USERNAME, COMMAND, COMMAND_NAME, s.STATUS, SCHEMANAME, OSUSER, PROCESS, MACHINE, PORT, TERMINAL, \
         s.PROGRAM, TYPE, s.SQL_ID, s.SQL_EXEC_START, s.SQL_EXEC_ID, SQL_TEXT, s.MODULE, s.ACTION, LOGON_TIME, LAST_CALL_ET, \
         FAILED_OVER, BLOCKING_SESSION_STATUS, EVENT, WAIT_CLASS, STATE, WAIT_TIME_MICRO, TIME_REMAINING_MICRO, s.SERVICE_NAME \
  FROM v$session s \
  LEFT OUTER JOIN v$sql_monitor m ON s.sql_id = m.sql_id AND s.sql_exec_start = m.sql_exec_start AND s.sql_exec_id = m.sql_exec_id \
  LEFT OUTER JOIN v$sqlcommand c ON s.command = c.command_type
insertSessionData=\
  INSERT INTO SESSION_DATA ( COLLECTED_AT, SID, DEVICE_ID, \
    SERIAL, USERNAME, COMMAND, COMMAND_NAME, STATUS, SCHEMANAME, OSUSER, PROCESS, MACHINE, PORT, TERMINAL, \
    PROGRAM, TYPE, SQL_ID, SQL_EXEC_START, SQL_EXEC_ID, SQL_TEXT, MODULE, ACTION, LOGON_TIME, LAST_CALL_ET, \
    FAILED_OVER, BLOCKING_SESSION_STATUS, EVENT, WAIT_CLASS, STATE, WAIT_TIME_MICRO, TIME_REMAINING_MICRO, SERVICE_NAME) \
  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
selectMetricData=\
  SELECT \
    (SELECT COUNT(*) FROM v$session) AS TOTAL_SESSION_COUNT, \
    (SELECT COUNT(*) FROM v$session WHERE STATUS = 'ACTIVE') AS ACTIVE_SESSION_COUNT, \
    (SELECT LISTAGG(USERNAME || ':' || SESSION_CNT, ', ') WITHIN GROUP (ORDER BY USERNAME) \
     FROM \
        (SELECT USERNAME, COUNT(*) AS SESSION_CNT \
         FROM v$session \
         WHERE USERNAME IS NOT NULL \
         GROUP BY USERNAME\
    )) AS SESSION_COUNT_GROUP_BY_USER, \
    (SELECT LISTAGG(COMMAND_NAME || ':' || COMMAND_CNT, ', ') WITHIN GROUP (ORDER BY COMMAND_NAME)\
     FROM \
        (SELECT c.COMMAND_NAME, COUNT(*) AS COMMAND_CNT \
         FROM (SELECT COMMAND FROM v$session WHERE COMMAND != 0) s JOIN v$sqlcommand c ON s.COMMAND = c.COMMAND_TYPE \
         WHERE COMMAND_NAME IS NOT NULL GROUP BY c.COMMAND_NAME\
        )) AS SESSION_COUNT_GROUP_BY_COMMAND, \
    (SELECT LISTAGG(MACHINE || ':' || MACHINE_CNT, ', ') WITHIN GROUP (ORDER BY MACHINE) \
     FROM \
        (SELECT MACHINE, COUNT(*) AS MACHINE_CNT \
         FROM v$session \
         GROUP BY MACHINE\
    )) AS SESSION_COUNT_GROUP_BY_MACHINE, \
    (SELECT LISTAGG(TYPE || ':' || TYPE_CNT, ', ') WITHIN GROUP (ORDER BY TYPE) \
     FROM \
        (SELECT TYPE, COUNT(*) AS TYPE_CNT \
         FROM v$session \
         GROUP BY TYPE\
    )) AS SESSION_COUNT_GROUP_BY_TYPE,\
    (SELECT COUNT(*) FROM v$session WHERE BLOCKING_SESSION_STATUS = 'VALID') AS BLOCKING_SESSION_COUNT, \
    (SELECT COUNT(*) FROM v$session WHERE STATE = 'WAITING' AND WAIT_CLASS != 'Idle') AS WAIT_SESSION_COUNT \
  FROM DUAL
insertMonitoringMetric=\
  INSERT INTO MONITORING_METRICS (COLLECTED_AT, DEVICE_ID, \
    TOTAL_SESSION_COUNT, ACTIVE_SESSION_COUNT, SESSION_COUNT_GROUP_BY_USER, SESSION_COUNT_GROUP_BY_COMMAND, \
    SESSION_COUNT_GROUP_BY_MACHINE, SESSION_COUNT_GROUP_BY_TYPE, BLOCKING_SESSION_COUNT, WAIT_SESSION_COUNT) \
  VALUES (:collectedAt, :deviceId, :totalSessionCount, :activeSessionCount, :sessionCountGroupByUser, \
          :sessionCountGroupByCommand, :sessionCountGroupByMachine, :sessionCountGroupByType, :blockingSessionCount, \
          :waitSessionCount)
deleteExpiredSessionDataList=\
  DELETE FROM SESSION_DATA \
  WHERE COLLECTED_AT < ?
deleteJobExecutionParamsDataList=\
  DELETE FROM BATCH_JOB_EXECUTION_PARAMS WHERE JOB_EXECUTION_ID IN \
(SELECT JOB_EXECUTION_ID FROM BATCH_JOB_EXECUTION WHERE CREATE_TIME < ?)
deleteJobExecutionContextDataList=\
  DELETE FROM BATCH_JOB_EXECUTION_CONTEXT WHERE JOB_EXECUTION_ID IN \
(SELECT JOB_EXECUTION_ID FROM BATCH_JOB_EXECUTION WHERE CREATE_TIME < ?)
deleteStepExecutionContext=\
DELETE FROM BATCH_STEP_EXECUTION_CONTEXT \
WHERE STEP_EXECUTION_ID IN ( \
    SELECT SE.STEP_EXECUTION_ID \
    FROM BATCH_STEP_EXECUTION SE \
    JOIN BATCH_JOB_EXECUTION JE ON SE.JOB_EXECUTION_ID = JE.JOB_EXECUTION_ID \
    WHERE JE.CREATE_TIME < ? \
)
deleteStepExecution=\
  DELETE FROM BATCH_STEP_EXECUTION WHERE JOB_EXECUTION_ID IN \
(SELECT JOB_EXECUTION_ID FROM BATCH_JOB_EXECUTION WHERE CREATE_TIME < ?)
deleteJobExecution=\
  DELETE FROM BATCH_JOB_EXECUTION WHERE CREATE_TIME < ?
deleteJobInstance=\
  DELETE FROM BATCH_JOB_INSTANCE \
  WHERE JOB_INSTANCE_ID IN ( \
    SELECT JI.JOB_INSTANCE_ID \
    FROM BATCH_JOB_INSTANCE JI \
    JOIN BATCH_JOB_EXECUTION JE ON JI.JOB_INSTANCE_ID = JE.JOB_INSTANCE_ID \
    WHERE JE.CREATE_TIME < ? \
  )

selectSessionDataForBackup=\
  SELECT /*+ PARALLEL(s 4) INDEX(s IDX_SESSION_DATA_COLLECTED) */ \
    s.COLLECTED_AT as COLLECTED_AT, \
    s.SID as SID, \
    s.DEVICE_ID as DEVICE_ID, \
    s.SERIAL as SERIAL, \
    s.USERNAME as USERNAME, \
    s.COMMAND as COMMAND, \
    s.COMMAND_NAME as COMMAND_NAME, \
    s.STATUS as STATUS, \
    s.SCHEMANAME as SCHEMA_NAME, \
    s.OSUSER as OS_USER, \
    s.PROCESS as PROCESS, \
    s.MACHINE as MACHINE, \
    s.PORT as PORT, \
    s.TERMINAL as TERMINAL, \
    s.PROGRAM as PROGRAM, \
    s.TYPE as TYPE, \
    s.SQL_ID as SQL_ID, \
    s.SQL_EXEC_START as SQL_EXEC_START, \
    s.SQL_EXEC_ID as SQL_EXEC_ID, \
    s.SQL_TEXT as SQL_TEXT, \
    s.MODULE as MODULE, \
    s.ACTION as ACTION, \
    s.LOGON_TIME as LOGON_TIME, \
    s.LAST_CALL_ET as LAST_CALL_ET, \
    s.FAILED_OVER as FAILED_OVER, \
    s.BLOCKING_SESSION_STATUS as BLOCKING_SESSION_STATUS, \
    s.EVENT as EVENT, \
    s.WAIT_CLASS as WAIT_CLASS, \
    s.STATE as STATE, \
    s.WAIT_TIME_MICRO as WAIT_TIME_MICRO, \
    s.TIME_REMAINING_MICRO as TIME_REMAINING_MICRO, \
    s.SERVICE_NAME as SERVICE_NAME, \
    d.COMPANY_ID as COMPANY_ID

fromSessionDataForBackup=\
  FROM SESSION_DATA s \
  INNER JOIN DEVICES d ON d.DEVICE_ID = s.DEVICE_ID

whereSessionDataForBackup=\
  WHERE s.COLLECTED_AT >= :startTime AND s.COLLECTED_AT < :endTime

selectRealTimeJobMetric=\
  WITH BASE_TIME AS ( \
    SELECT \
      TRUNC(SYSTIMESTAMP AT TIME ZONE 'Asia/Seoul', 'MI') + \
      NUMTODSINTERVAL(FLOOR(EXTRACT(SECOND FROM SYSTIMESTAMP AT TIME ZONE 'Asia/Seoul') / 5) * 5, 'SECOND') AS CURRENT_TIME \
    FROM DUAL \
  ), \
  TIME_SERIES AS ( \
    SELECT \
      (SELECT CURRENT_TIME FROM BASE_TIME) - NUMTODSINTERVAL((LEVEL-1)*5, 'SECOND') AS TIME_POINT \
    FROM DUAL \
    CONNECT BY LEVEL <= 36 \
  ) \
  SELECT \
    T.TIME_POINT AS START_TIME, \
    B.END_TIME, \
    CASE \
      WHEN B.END_TIME IS NULL THEN 0 \
      ELSE ROUND( \
        (EXTRACT(DAY FROM (B.END_TIME - B.START_TIME)) * 86400 + \
         EXTRACT(HOUR FROM (B.END_TIME - B.START_TIME)) * 3600 + \
         EXTRACT(MINUTE FROM (B.END_TIME - B.START_TIME)) * 60 + \
         EXTRACT(SECOND FROM (B.END_TIME - B.START_TIME))), \
        1 \
      ) \
    END AS DURATION_TIME_IN_HOURS \
  FROM TIME_SERIES T \
  LEFT JOIN BATCH_JOB_EXECUTION B \
    ON TO_TIMESTAMP(TO_CHAR(B.START_TIME, 'YYYY-MM-DD HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS') = \
       TO_TIMESTAMP(TO_CHAR(T.TIME_POINT, 'YYYY-MM-DD HH24:MI:SS'), 'YYYY-MM-DD HH24:MI:SS') \
  WHERE T.TIME_POINT <= (SELECT CURRENT_TIME FROM BASE_TIME) \
  ORDER BY T.TIME_POINT DESC
selectDailyJobExecutionTimes=\
  WITH DATE_RANGE AS ( \
    SELECT TRUNC(SYSDATE) - LEVEL AS EXEC_DATE \
    FROM DUAL \
    CONNECT BY LEVEL <= 6 \
  ), \
  JOB_DURATIONS AS ( \
    SELECT \
      TRUNC(B.START_TIME) AS EXEC_DATE, \
      I.JOB_NAME, \
      MAX(ROUND( \
        (EXTRACT(DAY FROM (B.END_TIME - B.START_TIME)) * 86400 + \
         EXTRACT(HOUR FROM (B.END_TIME - B.START_TIME)) * 3600 + \
         EXTRACT(MINUTE FROM (B.END_TIME - B.START_TIME)) * 60 + \
         EXTRACT(SECOND FROM (B.END_TIME - B.START_TIME))), \
        1 \
      )) AS DURATION_TIME \
    FROM BATCH_JOB_EXECUTION B \
    JOIN BATCH_JOB_INSTANCE I ON B.JOB_INSTANCE_ID = I.JOB_INSTANCE_ID \
    WHERE I.JOB_NAME IN ('storeCsvFileJob', 'retentionJob') \
      AND B.START_TIME >= TRUNC(SYSDATE) - 6 \
      AND B.START_TIME < TRUNC(SYSDATE) \
    GROUP BY TRUNC(B.START_TIME), I.JOB_NAME \
  ) \
  SELECT \
    D.EXEC_DATE, \
    NVL(STORE.DURATION_TIME, 0) AS STORE_JOB_DURATION, \
    NVL(RETENTION.DURATION_TIME, 0) AS RETENTION_JOB_DURATION \
  FROM DATE_RANGE D \
  LEFT JOIN JOB_DURATIONS STORE \
    ON D.EXEC_DATE = STORE.EXEC_DATE \
    AND STORE.JOB_NAME = 'storeCsvFileJob' \
  LEFT JOIN JOB_DURATIONS RETENTION \
    ON D.EXEC_DATE = RETENTION.EXEC_DATE \
    AND RETENTION.JOB_NAME = 'retentionJob' \
  ORDER BY D.EXEC_DATE DESC
selectStepDataMetric=\
  WITH STEP_DATA AS ( \
      SELECT \
          TO_CHAR(s.END_TIME, 'YYYY-MM-DD') AS EXEC_DATE, \
        COUNT(*) AS TOTAL_CNT \
    FROM BATCH_STEP_EXECUTION s \
    WHERE s.END_TIME >= TRUNC(SYSDATE) - INTERVAL '5' DAY \
        AND s.END_TIME < TRUNC(SYSDATE) + 1 \
    GROUP BY TO_CHAR(s.END_TIME, 'YYYY-MM-DD') \
  ), \
  ERROR_DATA AS ( \
    SELECT \
      TO_CHAR(TRUNC(s.END_TIME), 'YYYY-MM-DD') AS EXEC_DATE, \
      CASE \
        WHEN s.EXIT_MESSAGE LIKE '%java.lang.NullPointerException%' THEN 'Java NPE' \
        WHEN s.EXIT_MESSAGE LIKE '%HikariPool%' THEN 'Connection Error' \
        WHEN s.EXIT_MESSAGE LIKE '%org.springframework%' THEN 'Business Error' \
        ELSE 'etc' \
      END AS ERR_TYPE, \
      COUNT(*) AS ERR_CNT \
    FROM BATCH_STEP_EXECUTION s \
    WHERE s.EXIT_CODE = 'FAILED' \
      AND s.END_TIME >= TRUNC(SYSDATE) - INTERVAL '5' DAY \
      AND s.END_TIME < TRUNC(SYSDATE) + 1 \
    GROUP BY \
      TO_CHAR(TRUNC(s.END_TIME), 'YYYY-MM-DD'), \
      CASE \
        WHEN s.EXIT_MESSAGE LIKE '%java.lang.NullPointerException%' THEN 'Java NPE' \
        WHEN s.EXIT_MESSAGE LIKE '%HikariPool%' THEN 'Connection Error' \
        WHEN s.EXIT_MESSAGE LIKE '%org.springframework%' THEN 'Business Error' \
        ELSE 'etc' \
      END \
  ) \
  SELECT \
    m.EXEC_DATE, \
    'TOTAL_COUNT:' || m.TOTAL_CNT || \
    LISTAGG(', ERROR_TYPE:' || COALESCE(e.ERR_TYPE, 'No Error') || \
            ', ERROR_COUNT:' || COALESCE(e.ERR_CNT, 0), ', ') \
    WITHIN GROUP (ORDER BY e.ERR_TYPE) AS ERROR_INFO \
  FROM STEP_DATA m \
  LEFT JOIN ERROR_DATA e ON m.EXEC_DATE = e.EXEC_DATE \
  GROUP BY m.EXEC_DATE, m.TOTAL_CNT \
  ORDER BY m.EXEC_DATE DESC